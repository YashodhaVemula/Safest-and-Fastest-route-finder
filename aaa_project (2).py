# -*- coding: utf-8 -*-
"""AAA-PROJECT

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kW12kxVGCWqThkBXbrZry6_rGQAlEdrp
"""

!pip install osmnx networkx scikit-learn pandas folium geopy

pip install osmnx geopy folium

from google.colab import drive
drive.mount('/content/drive')

# Access the CSV file after mounting
import pandas as pd
df = pd.read_csv('/content/South_Crime_Details.csv') # Assuming the CSV file is in your 'MyDrive' folder

import pandas as pd

# Use pd.read_excel to read Excel files
df = pd.read_excel('/content/South_Crime_Details.xlsx')

!pip install osmnx

import osmnx as ox
import networkx as nx
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
import pandas as pd
import folium
from geopy.geocoders import Nominatim
import heapq

G = ox.graph_from_place('Bangalore South, India', network_type='drive')

# Convert the graph into NetworkX format
nx_graph = ox.graph_to_gdfs(G)

# View basic graph information
print(f"Number of nodes: {G.number_of_nodes()}")
print(f"Number of edges: {G.number_of_edges()}")
print(f"Graph is directed: {G.is_directed()}")

# Create a basic graph representation
graph = {}
for u, v, data in G.edges(data=True):
    length = data['length']
    if u not in graph:
        graph[u] = []
    graph[u].append((v, length))

# Ensure all nodes are initialized in the distances dictionary
for node in G.nodes:
    if node not in graph:
        graph[node] = []  # Initialize with an empty list if no edges

# Fetch the road network (Graph)
nodes, edges = ox.graph_to_gdfs(G)

# Check available columns
print(edges.columns)

# Use geometry to extract 'u' (start) and 'v' (end) of each edge
# You need to unpack the LineString in the geometry to get the nodes
def get_edge_nodes(geometry):
    coords = list(geometry.coords)
    u = coords[0]  # Start point
    v = coords[-1]  # End point
    return u, v

# Add 'u' and 'v' columns to the edges DataFrame
edges['u'], edges['v'] = zip(*edges['geometry'].apply(get_edge_nodes))

# Create a basic graph representation
graph = {}
for u, v, data in G.edges(data=True):
    length = data['length']
    if u not in graph:
        graph[u] = []
    graph[u].append((v, length))

# Ensure all nodes are initialized in the distances dictionary
for node in G.nodes:
    if node not in graph:
        graph[node] = []  # Initialize with an empty list if no edges

"""With proper classification"""

import pandas as pd

# Load crime data from the CSV file
crime_data_path = ('/content/South_Crime_Details.csv')
crime_data = pd.read_csv(crime_data_path, encoding='latin-1')

# Normalize the place names
crime_data['Place'] = crime_data['Place'].str.lower()

# Step 1: Assign a risk level to each crime type
crime_risk_levels = {
    'Ordinary Theft': 1,
    'Robbery': 2,
    'Kidnap':3,
    'Assault': 4,
    'Murder': 5,
    'other': 2  # General or less severe crimes as an example
}


# Map the risk level to each entry based on 'Type' column
crime_data['Risk_Level'] = crime_data['Type'].map(crime_risk_levels).fillna(1)

# Step 2: Drop rows with missing latitude or longitude values
crime_data.dropna(subset=['Latitude', 'Longitude'], inplace=True)

# Step 3: Aggregate risk levels by place and save directly to CSV
place_risk_mapping = (
    crime_data.groupby(['Place', 'Latitude', 'Longitude'], as_index=False)['Risk_Level']
    .max()
)

# Save to CSV file
output_path = 'Place_Risk_Mapping4.csv'
place_risk_mapping.to_csv(output_path, index=False)

print(f"Risk levels by place saved toÂ {output_path}")

# Extract unique crime-reported locations
crime_locations = place_risk_mapping[['Place', 'Latitude', 'Longitude']].drop_duplicates()
print("Crime-reported locations ready for data fetching.")

import pandas as pd
import osmnx as ox
from shapely.geometry import Point
import re

# Load the CSV file with crime locations
crime_data_path = 'Place_Risk_Mapping4.csv'
crime_locations = pd.read_csv(crime_data_path)

# Step 1: Filter out rows with invalid latitude and longitude values (non-decimal characters)
decimal_pattern = r'^\d+(\.\d+)?$'
crime_locations = crime_locations[
    crime_locations['Latitude'].astype(str).str.match(decimal_pattern) &
    crime_locations['Longitude'].astype(str).str.match(decimal_pattern)
]

# Convert latitude and longitude columns back to numeric types for further processing
crime_locations['Latitude'] = pd.to_numeric(crime_locations['Latitude'])
crime_locations['Longitude'] = pd.to_numeric(crime_locations['Longitude'])

print("Filtered data with valid decimal latitude and longitude values:")
print(crime_locations.head())

# Step 2: Define the tags for streetlights and crowd density indicators
streetlight_tags = {'highway': 'street_lamp'}
crowd_tags = {
    'amenity': ['bus_station', 'restaurant', 'cafe', 'bar', 'cinema', 'marketplace', 'mall'],
    'shop': True
}

# Set radius for fetching data (in meters)
radius = 500

# Create lists to store streetlight and crowd density data
streetlight_availability = []
crowd_density = []

# Step 3: Fetch streetlight and crowd data for each crime-reported location
for idx, row in crime_locations.iterrows():
    lat, lon = row['Latitude'], row['Longitude']
    location_point = Point(lon, lat)

    # Fetch streetlight data
    try:
        streetlight_data = ox.features_from_point(location_point, tags=streetlight_tags, dist=radius)
        has_streetlight = not streetlight_data.empty
    except Exception:
        has_streetlight = False  # Set False if no data available

    # Fetch crowd data
    try:
        crowd_data = ox.features_from_point(location_point, tags=crowd_tags, dist=radius)
        crowd_density_level = "High" if not crowd_data.empty else "Low"
    except Exception:
        crowd_density_level = "Low"  # Set Low if no data available

    # Append data
    streetlight_availability.append("Yes" if has_streetlight else "No")
    crowd_density.append(crowd_density_level)

# Step 4: Add the fetched data to the DataFrame
crime_locations['Streetlight'] = streetlight_availability
crime_locations['Crowd_Density'] = crowd_density

# Save updated data
output_path = 'Crime_Locations_with_Safety_Features.csv'
crime_locations.to_csv(output_path, index=False)
print(f"Streetlight and crowd density data added to crime-reported locations and saved to {output_path}")

import numpy as np
import pandas as pd

# Update streetlight and crowd density data based on crime risk level
np.random.seed(0)  # For reproducibility

def assign_streetlight_and_crowd(row):
    if row['Risk_Level'] > 3:  # High-risk crimes
        streetlight = np.random.choice(['Yes', 'No'], p=[0.3, 0.7])
        crowd_density = np.random.choice(['High', 'Low'], p=[0.4, 0.6])
    else:  # Lower-risk crimes
        streetlight = np.random.choice(['Yes', 'No'], p=[0.6, 0.4])
        crowd_density = np.random.choice(['High', 'Low'], p=[0.7, 0.3])
    return pd.Series([streetlight, crowd_density])

# Apply synthetic data generation to crime locations DataFrame
crime_locations[['Streetlight', 'Crowd_Density']] = crime_locations.apply(assign_streetlight_and_crowd, axis=1)

# Define safety criteria and apply to create the Safety_Label column
def classify_safety(row):
    if row['Risk_Level'] <= 2 and row['Streetlight'] == "Yes" and row['Crowd_Density'] == "High":
        return "Safe"
    else:
        return "Risky"

# Add Safety_Label to the same DataFrame
crime_locations['Safety_Label'] = crime_locations.apply(classify_safety, axis=1)

# Save updated data to CSV
crime_locations.to_csv('Crime_Locations_with_Safety_Features_v5.csv', index=False)
print("Synthetic streetlight and crowd density data, along with Safety_Label, added to crime_locations DataFrame.")

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.preprocessing import LabelEncoder
import pandas as pd

# Example of loading your dataset
data = pd.read_csv('Crime_Locations_with_Safety_Features_v5.csv')
# Encode categorical features
data['Streetlight'] = LabelEncoder().fit_transform(data['Streetlight'])
data['Crowd_Density'] = LabelEncoder().fit_transform(data['Crowd_Density'])

# Replace 'features' and 'target' with your actual column names
X = data[['Crowd_Density', 'Streetlight',]]  # Features (e.g., lighting, crowd density)
y = data['Safety_Label']  # Target variable (risk classification)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
# Initialize Random Forest with string class weights
rf_classifier = RandomForestClassifier(n_estimators=100, max_depth=5, class_weight={'Risky': 1, 'Safe': 1.5}, random_state=42)


rf_classifier.fit(X_train, y_train)
y_pred = rf_classifier.predict(X_test)
print(confusion_matrix(y_test, y_pred))
print(classification_report(y_test, y_pred))

import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.impute import SimpleImputer

# Load the data
data = pd.read_csv('Crime_Locations_with_Safety_Features_v5.csv')

# Encode categorical features
le = LabelEncoder()
data['Streetlight'] = le.fit_transform(data['Streetlight'])
data['Crowd_Density'] = le.fit_transform(data['Crowd_Density'])

# Prepare features and target
X = data[['Latitude', 'Longitude', 'Streetlight', 'Crowd_Density']]
y = data['Safety_Label']

# Handle missing values
imputer = SimpleImputer(strategy='mean')
X = pd.DataFrame(imputer.fit_transform(X), columns=X.columns)

# Split the data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train the Random Forest model
rf_classifier = RandomForestClassifier(n_estimators=100, max_depth=5, class_weight={'Risky': 1, 'Safe': 1.5}, random_state=42)
rf_classifier.fit(X_train, y_train)
# When training the model
feature_names = ['Crowd_Density', 'Streetlight']
X = data[feature_names]
y = data['Safety_Label']

rf_classifier = RandomForestClassifier(n_estimators=100, max_depth=5, class_weight={'Risky': 1, 'Safe': 1.5}, random_state=42)
rf_classifier.fit(X, y)
# Function to extract features for a given location
def extract_features(lat, lon, streetlight, crowd_density):
    return [lat, lon, streetlight, crowd_density]

# Function to predict safety score
def predict_safety_score(lat, lon, streetlight, crowd_density):
    features = extract_features(lat, lon, streetlight, crowd_density)
    prediction = rf_classifier.predict_proba([features])[0]
    # Return the probability of being 'Safe'
    return prediction[list(rf_classifier.classes_).index('Safe')]

# Create a dictionary of known safety scores
known_safety_scores = dict(zip(data['Place'], data['Risk_Level']))

import osmnx as ox
import folium
from geopy.geocoders import Nominatim
import heapq
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.impute import SimpleImputer

class SafeRouteFinder:
    def __init__(self):
        self.rf_classifier = None
        self.streetlight_encoder = LabelEncoder()
        self.crowd_density_encoder = LabelEncoder()
        self.imputer = SimpleImputer(strategy='mean')
        self.feature_names = ['Latitude', 'Longitude', 'Streetlight_Encoded', 'Crowd_Density_Encoded']
        self.G = None
        self.graph = {}
        self.safety_scores = {}

    def initialize_subgraph(self, start_coords, end_coords):
        """Initialize a smaller subgraph around the start and end locations."""
        try:
            central_point = [(start_coords[0] + end_coords[0]) / 2, (start_coords[1] + end_coords[1]) / 2]
            self.G = ox.graph_from_point(central_point, dist=3000, network_type='drive')
            self.graph = {u: [] for u in self.G.nodes()}
            for u, v, data in self.G.edges(data=True):
                self.graph[u].append((v, data['length']))

            print(f"Subgraph initialized with {len(self.G.nodes())} nodes and {len(self.G.edges())} edges.")
            return True
        except Exception as e:
            print(f"Error initializing subgraph: {str(e)}")
            return False

    def train_model(self):
        """Train the Random Forest model for safety prediction."""
        try:
            data = pd.read_csv('Crime_Locations_with_Safety_Features_v5.csv')
            data['Streetlight_Encoded'] = self.streetlight_encoder.fit_transform(data['Streetlight'])
            data['Crowd_Density_Encoded'] = self.crowd_density_encoder.fit_transform(data['Crowd_Density'])

            X = data[['Latitude', 'Longitude', 'Streetlight_Encoded', 'Crowd_Density_Encoded']]
            y = data['Safety_Label']

            X = pd.DataFrame(self.imputer.fit_transform(X), columns=X.columns)
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

            self.rf_classifier = RandomForestClassifier(
                n_estimators=50, max_depth=5, class_weight='balanced', random_state=42
            )
            self.rf_classifier.fit(X_train, y_train)
            print("Model trained successfully.")
            return True
        except Exception as e:
            print(f"Error training model: {str(e)}")
            return False

    def get_location_coordinates(self, location_name, attempts=3):
        """Get coordinates for a location with retries."""
        for attempt in range(attempts):
            try:
                geolocator = Nominatim(user_agent="route_finder_agent", timeout=10)
                location = geolocator.geocode(f"{location_name}, Bangalore South, India")
                if location:
                    print(f"Coordinates for '{location_name}': {location.latitude}, {location.longitude}")
                    return (location.latitude, location.longitude)
                else:
                    print(f"Could not find location: {location_name}")
                    return None
            except Exception as e:
                print(f"Error getting coordinates (Attempt {attempt + 1}): {str(e)}")
                if attempt == attempts - 1:  # Last attempt
                    return None


    def precompute_safety_scores(self):
        """Compute and store safety scores for nodes in the graph."""
        try:
            safety_data = pd.read_csv('Crime_Locations_with_Safety_Features_v5.csv')
            for index, row in safety_data.iterrows():
                node = ox.nearest_nodes(self.G, row['Longitude'], row['Latitude'])
                prediction = self.predict_safety(row)
                self.safety_scores[node] = 10 if prediction == 'Risky' else 0

            # Set default safety score for nodes without specific data
            for node in self.graph.keys():
                if node not in self.safety_scores:
                    self.safety_scores[node] = 5

            print("Safety scores precomputed successfully.")
            return True
        except Exception as e:
            print(f"Error precomputing safety scores: {str(e)}")
            return False

    def predict_safety(self, location_data):
        """Predict safety for a location."""
        try:
            streetlight_encoded = self.streetlight_encoder.transform([location_data['Streetlight']])[0]
            crowd_density_encoded = self.crowd_density_encoder.transform([location_data['Crowd_Density']])[0]

            X_pred = pd.DataFrame([[location_data['Latitude'], location_data['Longitude'],
                                    streetlight_encoded, crowd_density_encoded]],
                                  columns=self.feature_names)

            X_pred = pd.DataFrame(self.imputer.transform(X_pred), columns=X_pred.columns)
            return self.rf_classifier.predict(X_pred)[0]
        except Exception as e:
            print(f"Error predicting safety: {str(e)}")
            return 'Risky'

    def find_route(self, start_location, end_location, use_safety=False):
        """Find the shortest or safest route between two locations."""
        try:
            start_coords = self.get_location_coordinates(start_location)
            end_coords = self.get_location_coordinates(end_location)

            if start_coords is None or end_coords is None:
                return "Error: Could not find coordinates for one or both locations."

            if not self.initialize_subgraph(start_coords, end_coords):
                return "Error: Could not initialize the graph."

            if use_safety and not self.precompute_safety_scores():
                return "Failed to compute safety scores"

            start_node = ox.nearest_nodes(self.G, start_coords[1], start_coords[0])
            end_node = ox.nearest_nodes(self.G, end_coords[1], end_coords[0])

            path, distance = self.dijkstra(start_node, end_node, use_safety)
            if not path:
                return "No route found between these locations."

            return path, distance, start_coords, end_coords

        except Exception as e:
            return f"Error finding route: {str(e)}"

    def dijkstra(self, start, end, use_safety):
        """Dijkstra's algorithm with optional safety scores."""
        try:
            distances = {node: float('inf') for node in self.graph}
            distances[start] = 0
            previous_nodes = {node: None for node in self.graph}
            priority_queue = [(0, start)]

            safety_weight = 10 if use_safety else 0

            while priority_queue:
                current_distance, current_node = heapq.heappop(priority_queue)

                if current_node == end:
                    break

                if current_distance > distances[current_node]:
                    continue

                for neighbor, weight in self.graph[current_node]:
                    safety_factor = self.safety_scores.get(neighbor, 5) * safety_weight
                    distance = current_distance + weight + safety_factor

                    if distance < distances[neighbor]:
                        distances[neighbor] = distance
                        previous_nodes[neighbor] = current_node
                        heapq.heappush(priority_queue, (distance, neighbor))

            if distances[end] == float('inf'):
                return None, None

            path = []
            current_node = end
            while current_node is not None:
                path.insert(0, current_node)
                current_node = previous_nodes[current_node]

            return path, distances[end]

        except Exception as e:
            print(f"Error in Dijkstra's algorithm: {str(e)}")
            return None, None

    def display_route(self, route_result, start_location, end_location, use_safety):
        """Display the route on a map using Folium."""
        if isinstance(route_result, str):
            print(route_result)
            return

        path, distance, start_coords, end_coords = route_result

        try:
            # Initialize the map centered on the starting location
            route_map = folium.Map(location=start_coords, zoom_start=13)

            # Mark the starting and ending locations
            folium.Marker(
                start_coords, popup=f"Start: {start_location}", icon=folium.Icon(color='green')
            ).add_to(route_map)
            folium.Marker(
                end_coords, popup=f"End: {end_location}", icon=folium.Icon(color='red')
            ).add_to(route_map)

            # Draw the route
            route_coords = [(self.G.nodes[node]['y'], self.G.nodes[node]['x']) for node in path]
            folium.PolyLine(
                route_coords, color="orange" if use_safety else "blue", weight=5, opacity=0.8
            ).add_to(route_map)

            # Save the map as an HTML file
            route_map.save('route_map2.html')
            print(f"Route found! Total distance: {distance / 1000:.2f} km")
            print("Map saved as 'route_map2.html'")

        except Exception as e:
            print(f"Error displaying route: {str(e)}")

def main():
    print("Welcome to Bangalore South Route Finder!")
    route_finder = SafeRouteFinder()
    if not route_finder.train_model():
        print("Failed to train the model. Exiting.")
        return

    while True:
        start = input("Enter starting location: ")
        end = input("Enter destination: ")
        use_safety = input("Use safety feature? (yes/no): ").lower() == 'yes'

        route_result = route_finder.find_route(start, end, use_safety)
        route_finder.display_route(route_result, start, end, use_safety)

        # Option to continue or exit
        if input("Do you want to find another route? (yes/no): ").lower() != 'yes':
            print("Thank you for using Bangalore South Route Finder! Exiting.")
            break

if __name__ == "__main__":
    main()

import osmnx as ox
import folium
from geopy.geocoders import Nominatim
import heapq
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.impute import SimpleImputer

class SafeRouteFinder:
    def __init__(self):
        self.rf_classifier = None
        self.streetlight_encoder = LabelEncoder()
        self.crowd_density_encoder = LabelEncoder()
        self.imputer = SimpleImputer(strategy='mean')
        self.feature_names = ['Latitude', 'Longitude', 'Streetlight_Encoded', 'Crowd_Density_Encoded']
        self.G = None
        self.graph = {}
        self.safety_scores = {}

    def initialize_subgraph(self, start_coords, end_coords):
        """Initialize a smaller subgraph around the start and end locations."""
        try:
            central_point = [(start_coords[0] + end_coords[0]) / 2, (start_coords[1] + end_coords[1]) / 2]
            self.G = ox.graph_from_point(central_point, dist=3000, network_type='drive')
            self.graph = {u: [] for u in self.G.nodes()}
            for u, v, data in self.G.edges(data=True):
                self.graph[u].append((v, data['length']))

            print(f"Subgraph initialized with {len(self.G.nodes())} nodes and {len(self.G.edges())} edges.")
            return True
        except Exception as e:
            print(f"Error initializing subgraph: {str(e)}")
            return False

    def train_model(self):
        """Train the Random Forest model for safety prediction."""
        try:
            data = pd.read_csv('Crime_Locations_with_Safety_Features_v5.csv')
            data['Streetlight_Encoded'] = self.streetlight_encoder.fit_transform(data['Streetlight'])
            data['Crowd_Density_Encoded'] = self.crowd_density_encoder.fit_transform(data['Crowd_Density'])

            X = data[['Latitude', 'Longitude', 'Streetlight_Encoded', 'Crowd_Density_Encoded']]
            y = data['Safety_Label']

            X = pd.DataFrame(self.imputer.fit_transform(X), columns=X.columns)
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

            self.rf_classifier = RandomForestClassifier(
                n_estimators=50, max_depth=5, class_weight='balanced', random_state=42
            )
            self.rf_classifier.fit(X_train, y_train)
            print("Model trained successfully.")
            return True
        except Exception as e:
            print(f"Error training model: {str(e)}")
            return False

    def get_location_coordinates(self, location_name, attempts=3):
        """Get coordinates for a location with retries."""
        for attempt in range(attempts):
            try:
                geolocator = Nominatim(user_agent="route_finder_agent", timeout=10)
                location = geolocator.geocode(f"{location_name}, Bangalore South, India")
                if location:
                    print(f"Coordinates for '{location_name}': {location.latitude}, {location.longitude}")
                    return (location.latitude, location.longitude)
                else:
                    print(f"Could not find location: {location_name}")
                    return None
            except Exception as e:
                print(f"Error getting coordinates (Attempt {attempt + 1}): {str(e)}")
                if attempt == attempts - 1:  # Last attempt
                    return None


    def precompute_safety_scores(self):
        """Compute and store safety scores for nodes in the graph."""
        try:
            safety_data = pd.read_csv('Crime_Locations_with_Safety_Features_v5.csv')
            for index, row in safety_data.iterrows():
                node = ox.nearest_nodes(self.G, row['Longitude'], row['Latitude'])
                prediction = self.predict_safety(row)
                self.safety_scores[node] = 10 if prediction == 'Risky' else 0

            # Set default safety score for nodes without specific data
            for node in self.graph.keys():
                if node not in self.safety_scores:
                    self.safety_scores[node] = 5

            print("Safety scores precomputed successfully.")
            return True
        except Exception as e:
            print(f"Error precomputing safety scores: {str(e)}")
            return False

    def predict_safety(self, location_data):
        """Predict safety for a location."""
        try:
            streetlight_encoded = self.streetlight_encoder.transform([location_data['Streetlight']])[0]
            crowd_density_encoded = self.crowd_density_encoder.transform([location_data['Crowd_Density']])[0]

            X_pred = pd.DataFrame([[location_data['Latitude'], location_data['Longitude'],
                                    streetlight_encoded, crowd_density_encoded]],
                                  columns=self.feature_names)

            X_pred = pd.DataFrame(self.imputer.transform(X_pred), columns=X_pred.columns)
            return self.rf_classifier.predict(X_pred)[0]
        except Exception as e:
            print(f"Error predicting safety: {str(e)}")
            return 'Risky'

    def find_route(self, start_location, end_location, use_safety=False):
        """Find the shortest or safest route between two locations."""
        try:
            start_coords = self.get_location_coordinates(start_location)
            end_coords = self.get_location_coordinates(end_location)

            if start_coords is None or end_coords is None:
                return "Error: Could not find coordinates for one or both locations."

            if not self.initialize_subgraph(start_coords, end_coords):
                return "Error: Could not initialize the graph."

            if use_safety and not self.precompute_safety_scores():
                return "Failed to compute safety scores"

            start_node = ox.nearest_nodes(self.G, start_coords[1], start_coords[0])
            end_node = ox.nearest_nodes(self.G, end_coords[1], end_coords[0])

            path, distance = self.dijkstra(start_node, end_node, use_safety)
            if not path:
                return "No route found between these locations."

            return path, distance, start_coords, end_coords

        except Exception as e:
            return f"Error finding route: {str(e)}"

    def dijkstra(self, start, end, use_safety):
        """Dijkstra's algorithm with optional safety scores."""
        try:
            distances = {node: float('inf') for node in self.graph}
            distances[start] = 0
            previous_nodes = {node: None for node in self.graph}
            priority_queue = [(0, start)]

            safety_weight = 10 if use_safety else 0

            while priority_queue:
                current_distance, current_node = heapq.heappop(priority_queue)

                if current_node == end:
                    break

                if current_distance > distances[current_node]:
                    continue

                for neighbor, weight in self.graph[current_node]:
                    safety_factor = self.safety_scores.get(neighbor, 5) * safety_weight
                    distance = current_distance + weight + safety_factor

                    if distance < distances[neighbor]:
                        distances[neighbor] = distance
                        previous_nodes[neighbor] = current_node
                        heapq.heappush(priority_queue, (distance, neighbor))

            if distances[end] == float('inf'):
                return None, None

            path = []
            current_node = end
            while current_node is not None:
                path.insert(0, current_node)
                current_node = previous_nodes[current_node]

            return path, distances[end]

        except Exception as e:
            print(f"Error in Dijkstra's algorithm: {str(e)}")
            return None, None

    def display_route(self, route_result, start_location, end_location, use_safety):
        """Display the route on a map using Folium."""
        if isinstance(route_result, str):
            print(route_result)
            return

        path, distance, start_coords, end_coords = route_result

        try:
            # Initialize the map centered on the starting location
            route_map = folium.Map(location=start_coords, zoom_start=13)

            # Mark the starting and ending locations
            folium.Marker(
                start_coords, popup=f"Start: {start_location}", icon=folium.Icon(color='green')
            ).add_to(route_map)
            folium.Marker(
                end_coords, popup=f"End: {end_location}", icon=folium.Icon(color='red')
            ).add_to(route_map)

            # Draw the route
            route_coords = [(self.G.nodes[node]['y'], self.G.nodes[node]['x']) for node in path]
            folium.PolyLine(
                route_coords, color="orange" if use_safety else "blue", weight=5, opacity=0.8
            ).add_to(route_map)

            # Save the map as an HTML file
            route_map.save('route_map_shortest.html')
            print(f"Route found! Total distance: {distance / 1000:.2f} km")
            print("Map saved as 'route_map_shortest.html'")

        except Exception as e:
            print(f"Error displaying route: {str(e)}")

def main():
    print("Welcome to Bangalore South Route Finder!")
    route_finder = SafeRouteFinder()
    if not route_finder.train_model():
        print("Failed to train the model. Exiting.")
        return

    while True:
        start = input("Enter starting location: ")
        end = input("Enter destination: ")
        use_safety = input("Use safety feature? (yes/no): ").lower() == 'yes'

        route_result = route_finder.find_route(start, end, use_safety)
        route_finder.display_route(route_result, start, end, use_safety)

        # Option to continue or exit
        if input("Do you want to find another route? (yes/no): ").lower() != 'yes':
            print("Thank you for using Bangalore South Route Finder! Exiting.")
            break

if __name__ == "__main__":
    main()

import random
import pandas as pd

# Define the list of 12 places in South Bengaluru
places = [
    "Koramangala", "Jayanagar", "Btm Layout", "Banashankari", "Madiwala",
    "Hosur Road", "Electronic City", "Bannerghatta Road", "Wilson Garden",
    "Ulsoor", "Shanthinagar", "Richmond Town"
]

def main():
    print("Welcome to Bangalore South Route Finder!")
    route_finder = SafeRouteFinder()

    # Train the model
    if not route_finder.train_model():
        print("Failed to train the model. Exiting.")
        return

    # Randomly select 3 pairs of locations from the list
    pairs = random.sample([(start, end) for start in places for end in places if start != end], 3)

    # Create an empty list to store results
    results = []

    for start_location, end_location in pairs:
        print(f"Finding route from {start_location} to {end_location}...")

        # Find the shortest route
        shortest_route_result = route_finder.find_route(start_location, end_location, use_safety=False)
        if isinstance(shortest_route_result, tuple):
            shortest_path, shortest_distance, _, _ = shortest_route_result
            shortest_distance_km = shortest_distance / 1000
        else:
            shortest_distance_km = "N/A"

        # Find the safest route
        safest_route_result = route_finder.find_route(start_location, end_location, use_safety=True)
        if isinstance(safest_route_result, tuple):
            safest_path, safest_distance, _, _ = safest_route_result
            safest_distance_km = safest_distance / 1000
        else:
            safest_distance_km = "N/A"

        # Append the result as a dictionary
        results.append({
            'Start Location': start_location,
            'End Location': end_location,
            'Shortest Distance (km)': shortest_distance_km,
            'Safest Distance (km)': safest_distance_km
        })

    # Create a DataFrame from the results
    df = pd.DataFrame(results)
    print("\nRoute Results (Shortest vs Safest):")
    print(df)

if __name__ == "__main__":
    main()